<!DOCTYPE html>
<html lang="no">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pixel City Deluxe</title>
    <style>
        :root {
            --ui-bg: rgba(20, 20, 25, 0.95);
            --accent: #f1c40f;
            --road-color: #4a4a4a;
            --sidewalk-color: #777;
            --grass-color: #4CAF50;
            --player-color: #3498db;
        }

        body {
            margin: 0;
            background-color: #111;
            color: white;
            font-family: 'Segoe UI', Tahoma, sans-serif;
            overflow: hidden;
            touch-action: none; /* Stopper all zooming og scrolling */
            user-select: none;
        }

        #game-wrapper {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        canvas {
            /* Behlder image-rendering: pixelated for √• ikke "blur" detaljene, men TILE_SIZE gj√∏r det mindre synlig */
            image-rendering: pixelated; 
            border: 4px solid #333;
            background-color: var(--grass-color);
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
        }

        #hud {
            position: fixed;
            top: 20px;
            left: 20px;
            background: var(--ui-bg);
            padding: 15px;
            border-radius: 12px;
            border-left: 6px solid var(--accent);
            min-width: 120px;
        }

        .stat-val { font-size: 24px; font-weight: 800; color: var(--accent); }
        .stat-label { font-size: 10px; text-transform: uppercase; opacity: 0.7; }

        /* Styring */
        #controls {
            position: fixed;
            bottom: 30px;
            right: 30px;
            display: grid;
            grid-template-columns: repeat(3, 80px);
            grid-template-rows: repeat(2, 80px);
            gap: 15px;
        }

        .btn {
            width: 80px;
            height: 80px;
            background: #2c3e50;
            border: none;
            border-radius: 15px;
            color: white;
            font-size: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 6px 0 #1a252f;
        }

        .btn:active {
            transform: translateY(4px);
            box-shadow: 0 2px 0 #1a252f;
        }

        #up { grid-column: 2; }
        #left { grid-column: 1; grid-row: 2; }
        #down { grid-column: 2; grid-row: 2; }
        #right { grid-column: 3; grid-row: 3; } /* Endret til 3 for √• gi plass til kj√∏p-knapp */
        
        #buy-area {
            position: fixed;
            bottom: 30px;
            left: 30px;
        }

        #buy-btn {
            padding: 20px 40px;
            background: #e67e22;
            border: none;
            color: white;
            font-weight: bold;
            border-radius: 15px;
            box-shadow: 0 6px 0 #a04000;
            cursor: pointer;
            font-size: 18px;
        }

        #buy-btn:active:not(:disabled) {
            transform: translateY(4px);
            box-shadow: 0 2px 0 #a04000;
        }

        #buy-btn:disabled {
            background: #555;
            box-shadow: 0 6px 0 #333;
            opacity: 0.5;
            cursor: not-allowed;
        }
    </style>
</head>
<body>

<div id="game-wrapper">
    <canvas id="cityCanvas"></canvas>
</div>

<div id="hud">
    <div class="stat-label">Mynter</div>
    <div class="stat-val" id="coin-txt">0</div>
    <div style="height: 10px;"></div>
    <div class="stat-label">By-St√∏rrelse</div>
    <div class="stat-val" id="size-txt">10x10</div>
</div>

<div id="buy-area">
    <button id="buy-btn" onclick="expandCity()">UTVID BYEN (10 ü™ô)</button>
</div>

<div id="controls">
    <div class="btn" id="up">‚ñ≤</div>
    <div class="btn" id="left">‚óÄ</div>
    <div class="btn" id="down">‚ñº</div>
    <div class="btn" id="right">‚ñ∂</div>
</div>

<script>
    const canvas = document.getElementById('cityCanvas');
    const ctx = canvas.getContext('2d');

    // Spillinnstillinger
    const TILE_SIZE = 60; // √òkt st√∏rrelse for mindre pikselert f√∏lelse
    let gridDim = 10; 
    let grid = []; // 0=Gress/Bygning, 1=Vei, 2=Mynt, 3=Park
    let buildingTypes = []; // Lagrer type for hver bygning
    
    let coins = 0;
    let player = { x: 2, y: 2 };
    
    // Kamera-innstillinger
    const viewSize = 720; // St√∏rre visningsomr√•de
    canvas.width = viewSize;
    canvas.height = viewSize;

    // Bygningstyper for generering
    const Building = {
        HOUSE: 0,
        COMMERCIAL: 1,
        SKYSCRAPER: 2,
        PARK_TREE: 3,
        PARK_BENCH: 4,
        PARK_POND: 5
    };

    function initGrid(newDim) {
        let oldGrid = grid;
        let oldBuildingTypes = buildingTypes;

        gridDim = newDim;
        grid = Array(gridDim).fill().map(() => Array(gridDim).fill(0));
        buildingTypes = Array(gridDim).fill().map(() => Array(gridDim).fill(0));

        // Kopier gamle data
        for(let y=0; y<oldGrid.length; y++) {
            for(let x=0; x<oldGrid[y].length; x++) {
                grid[y][x] = oldGrid[y][x];
                buildingTypes[y][x] = oldBuildingTypes[y][x];
            }
        }
        
        // Generer nye veier og bygninger i det nye omr√•det
        for(let y=0; y<gridDim; y++) {
            for(let x=0; x<gridDim; x++) {
                if(grid[y][x] === 0) { // Hvis det er nytt gress
                    // Tilfeldig bygning eller park
                    let rand = Math.random();
                    if (rand < 0.6) buildingTypes[y][x] = Math.floor(Math.random() * 3); // Hus, Forretning, Skyskraper
                    else buildingTypes[y][x] = Math.floor(Math.random() * 3) + 3; // Tre, Benk, Dam
                    
                    if (buildingTypes[y][x] >= Building.PARK_TREE) {
                        grid[y][x] = 3; // Markerer som park-rute
                    }
                }
            }
        }

        // Start-veier
        // S√∏rg for at startveiene er p√• riktig sted i det nye, st√∏rre kartet
        for(let i=0; i<gridDim; i++) {
            grid[player.y][i] = 1;
            grid[i][player.x] = 1;
        }

        // Klargj√∏r nye omr√•der for utforskning
        spawnCoin();
    }

    function spawnCoin() {
        let roadTiles = [];
        for(let y=0; y<gridDim; y++) {
            for(let x=0; x<gridDim; x++) {
                if(grid[y][x] === 1) roadTiles.push({x, y});
            }
        }
        if(roadTiles.length > 0) {
            let pos = roadTiles[Math.floor(Math.random() * roadTiles.length)];
            grid[pos.y][pos.x] = 2; // Mynt
        }
    }

    function isRoad(x, y) {
        return x >= 0 && x < gridDim && y >= 0 && y < gridDim && grid[y][x] === 1;
    }

    function drawTile(x, y, offsetX, offsetY) {
        const tx = x * TILE_SIZE + offsetX;
        const ty = y * TILE_SIZE + offsetY;

        // Hopp over tegning hvis utenfor skjermen
        if (tx + TILE_SIZE < 0 || tx > viewSize || ty + TILE_SIZE < 0 || ty > viewSize) return;

        // 1. GRESS/GRUNN
        ctx.fillStyle = "#699e69"; // Lysere gress
        ctx.fillRect(tx, ty, TILE_SIZE, TILE_SIZE);
        ctx.fillStyle = "rgba(0,0,0,0.05)"; // Skygge
        ctx.fillRect(tx, ty + TILE_SIZE - 5, TILE_SIZE, 5); // Base-skygge

        if(grid[y][x] === 1) { // VEI
            ctx.fillStyle = varColor('--road-color');
            ctx.fillRect(tx, ty, TILE_SIZE, TILE_SIZE);
            
            // Bitmasking for fortau og veistriper
            let neighbors = {
                N: isRoad(x, y-1), S: isRoad(x, y+1),
                W: isRoad(x-1, y), E: isRoad(x+1, y)
            };

            ctx.fillStyle = varColor('--sidewalk-color');
            const sidewalkThickness = 8; // Tykkelse p√• fortau

            if (!neighbors.N) ctx.fillRect(tx, ty, TILE_SIZE, sidewalkThickness);
            if (!neighbors.S) ctx.fillRect(tx, ty + TILE_SIZE - sidewalkThickness, TILE_SIZE, sidewalkThickness);
            if (!neighbors.W) ctx.fillRect(tx, ty, sidewalkThickness, TILE_SIZE);
            if (!neighbors.E) ctx.fillRect(tx + TILE_SIZE - sidewalkThickness, ty, sidewalkThickness, TILE_SIZE);

            // Tegn hj√∏rner p√• fortau der det er "inngang" til gress
            ctx.fillStyle = varColor('--sidewalk-color');
            if(!neighbors.N && !neighbors.W) ctx.fillRect(tx, ty, sidewalkThickness, sidewalkThickness);
            if(!neighbors.N && !neighbors.E) ctx.fillRect(tx + TILE_SIZE - sidewalkThickness, ty, sidewalkThickness, sidewalkThickness);
            if(!neighbors.S && !neighbors.W) ctx.fillRect(tx, ty + TILE_SIZE - sidewalkThickness, sidewalkThickness, sidewalkThickness);
            if(!neighbors.S && !neighbors.E) ctx.fillRect(tx + TILE_SIZE - sidewalkThickness, ty + TILE_SIZE - sidewalkThickness, sidewalkThickness, sidewalkThickness);

            // Veistriper - Mer detaljert
            ctx.fillStyle = "rgba(255,255,255,0.15)";
            const stripWidth = 6;
            const stripLength = 10;
            const stripGap = 15;

            if (neighbors.N && neighbors.S) { // Vertikal vei
                for (let i = 0; i < TILE_SIZE; i += stripGap) {
                    ctx.fillRect(tx + TILE_SIZE/2 - stripWidth/2, ty + i, stripWidth, stripLength);
                }
            }
            if (neighbors.W && neighbors.E) { // Horisontal vei
                for (let i = 0; i < TILE_SIZE; i += stripGap) {
                    ctx.fillRect(tx + i, ty + TILE_SIZE/2 - stripWidth/2, stripLength, stripWidth);
                }
            }

        } else if (grid[y][x] === 3) { // PARK
            // Gress-bakgrunn er allerede tegnet
            let parkType = buildingTypes[y][x];
            if (parkType === Building.PARK_TREE) {
                ctx.fillStyle = "#8B4513"; // Stamme
                ctx.fillRect(tx + TILE_SIZE/2 - 4, ty + TILE_SIZE/2 + 5, 8, 15);
                ctx.fillStyle = "#228B22"; // Krone
                ctx.beginPath();
                ctx.arc(tx + TILE_SIZE/2, ty + TILE_SIZE/2 - 5, 15, 0, Math.PI * 2);
                ctx.fill();
            } else if (parkType === Building.PARK_BENCH) {
                ctx.fillStyle = "#8B4513"; // Benk
                ctx.fillRect(tx + 10, ty + TILE_SIZE/2 - 5, TILE_SIZE - 20, 10);
                ctx.fillRect(tx + 12, ty + TILE_SIZE/2 - 15, 5, 10);
                ctx.fillRect(tx + TILE_SIZE - 17, ty + TILE_SIZE/2 - 15, 5, 10);
            } else if (parkType === Building.PARK_POND) {
                ctx.fillStyle = "#4682B4"; // Dam
                ctx.beginPath();
                ctx.ellipse(tx + TILE_SIZE/2, ty + TILE_SIZE/2, TILE_SIZE/2 - 10, TILE_SIZE/2 - 15, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = "#A9D0F5"; // Vannrefleksjon
                ctx.fillRect(tx + TILE_SIZE/2 - 10, ty + TILE_SIZE/2 + 5, 20, 5);
            }
        } else if (grid[y][x] === 0) { // BYGNINGER
            let bType = buildingTypes[y][x];
            ctx.fillStyle = "rgba(0,0,0,0.3)"; // Skygge
            ctx.fillRect(tx+10, ty+14, TILE_SIZE-20, TILE_SIZE-20);
            
            if (bType === Building.HOUSE) {
                ctx.fillStyle = "#e74c3c"; // Vegger
                ctx.fillRect(tx+10, ty+10, TILE_SIZE-20, TILE_SIZE-25);
                ctx.fillStyle = "#c0392b"; // Tak
                ctx.beginPath();
                ctx.moveTo(tx+10, ty+10); ctx.lineTo(tx+TILE_SIZE/2, ty+5); ctx.lineTo(tx+TILE_SIZE-10, ty+10);
                ctx.fill();
                ctx.fillStyle = "#f1c40f"; // Vindu
                ctx.fillRect(tx+15, ty+15, 10, 10);
            } else if (bType === Building.COMMERCIAL) {
                ctx.fillStyle = "#95a5a6"; // Vegger
                ctx.fillRect(tx+8, ty+8, TILE_SIZE-16, TILE_SIZE-16);
                ctx.fillStyle = "#3498db"; // Vindu
                ctx.fillRect(tx+12, ty+12, 12, 8);
                ctx.fillRect(tx+TILE_SIZE-24, ty+12, 12, 8);
            } else if (bType === Building.SKYSCRAPER) {
                ctx.fillStyle = "#7f8c8d"; // Vegger
                ctx.fillRect(tx+12, ty+4, TILE_SIZE-24, TILE_SIZE-8);
                ctx.fillStyle = "#555"; // Tak
                ctx.fillRect(tx+12, ty+4, TILE_SIZE-24, 4);
                ctx.fillStyle = "#3498db"; // Vindu
                ctx.fillRect(tx+15, ty+10, 6, 6);
                ctx.fillRect(tx+15, ty+20, 6, 6);
                ctx.fillRect(tx+25, ty+10, 6, 6);
                ctx.fillRect(tx+25, ty+20, 6, 6);
            }
        }

        if(grid[y][x] === 2) { // MYNT
            ctx.fillStyle = varColor('--accent');
            const bounce = Math.sin(Date.now() / 200) * 3;
            ctx.beginPath();
            ctx.arc(tx + TILE_SIZE/2, ty + TILE_SIZE/2 + bounce, 12, 0, Math.PI*2);
            ctx.fill();
            ctx.strokeStyle = "white";
            ctx.lineWidth = 2;
            ctx.stroke();
        }
    }

    function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const camX = player.x * TILE_SIZE - (viewSize / 2) + (TILE_SIZE / 2);
        const camY = player.y * TILE_SIZE - (viewSize / 2) + (TILE_SIZE / 2);
        
        for(let y=0; y<gridDim; y++) {
            for(let x=0; x<gridDim; x++) {
                drawTile(x, y, -camX, -camY);
            }
        }

        // Tegn spilleren i sentrum av visningen
        const playerDrawX = (viewSize / 2) - (TILE_SIZE / 2);
        const playerDrawY = (viewSize / 2) - (TILE_SIZE / 2);

        ctx.fillStyle = "rgba(0,0,0,0.3)"; // Spiller-skygge
        ctx.beginPath();
        ctx.ellipse(playerDrawX + TILE_SIZE/2, playerDrawY + TILE_SIZE - 8, TILE_SIZE/2 - 10, 6, 0, 0, Math.PI*2);
        ctx.fill();
        
        ctx.fillStyle = varColor('--player-color'); // Kropp
        ctx.fillRect(playerDrawX + 15, playerDrawY + 20, TILE_SIZE-30, TILE_SIZE-30);
        ctx.fillStyle = "#f3dbc2"; // Hode
        ctx.fillRect(playerDrawX + 18, playerDrawY + 8, TILE_SIZE-36, TILE_SIZE-36);
        ctx.fillStyle = "#222"; // √òyne
        ctx.fillRect(playerDrawX + 22, playerDrawY + 14, 3, 3);
        ctx.fillRect(playerDrawX + TILE_SIZE - 25, playerDrawY + 14, 3, 3);

        requestAnimationFrame(render);
    }

    function move(dx, dy) {
        let nx = player.x + dx;
        let ny = player.y + dy;

        if(nx >= 0 && nx < gridDim && ny >= 0 && ny < gridDim) {
            if(grid[ny][nx] === 1 || grid[ny][nx] === 2) { // Kan bare g√• p√• vei eller mynt
                player.x = nx;
                player.y = ny;

                if(grid[ny][nx] === 2) {
                    grid[ny][nx] = 1;
                    coins++;
                    updateUI();
                    spawnCoin();
                }
            }
        }
    }

    function expandCity() {
        if(coins >= 10) {
            coins -= 10;
            const oldDim = gridDim;
            gridDim += 5; // √òk dimensjonen
            initGrid(gridDim); // Re-initialiser med ny dimensjon

            // Generer nye veier i det ekspanderte omr√•det for tilkobling
            for(let i = oldDim; i < gridDim; i++) { // Legg til vei langs nye grenser
                grid[i][Math.floor(oldDim/2)] = 1;
                grid[Math.floor(oldDim/2)][i] = 1;
            }

            // Flytt spilleren til en sentral posisjon i det nye kartet hvis n√∏dvendig
            if (player.x >= oldDim - 2) player.x = oldDim - 2;
            if (player.y >= oldDim - 2) player.y = oldDim - 2;

            updateUI();
            draw();
        }
    }

    function updateUI() {
        document.getElementById('coin-txt').innerText = coins;
        document.getElementById('size-txt').innerText = `${gridDim}x${gridDim}`;
        document.getElementById('buy-btn').disabled = coins < 10;
    }

    // Input-h√•ndtering
    const dirs = { 'up': [0, -1], 'down': [0, 1], 'left': [-1, 0], 'right': [1, 0] };
    Object.keys(dirs).forEach(id => {
        const btn = document.getElementById(id);
        const handler = (e) => { e.preventDefault(); move(...dirs[id]); };
        btn.addEventListener('touchstart', handler, { passive: false });
        btn.addEventListener('mousedown', handler);
    });

    window.addEventListener('keydown', (e) => {
        if(e.key === "ArrowUp") move(0, -1);
        if(e.key === "ArrowDown") move(0, 1);
        if(e.key === "ArrowLeft") move(-1, 0);
        if(e.key === "ArrowRight") move(1, 0);
    });

    initGrid(gridDim);
    updateUI();
    draw();
</script>

</body>
</html>
